# 最小生成树有三种算法，你晓得么？

## 简述

大家好啊，我是奥克苏恩。今天来给大家介绍一下最小生成树的三种算法。

在讲算法之前，我们要问：最小生成树是什么？

好吧，让我们先把“最小”两个字去掉：生成树是什么？

简单来说，就是在一个无向连通图中的一个极小连通子图，它包含原图所有的结点，并且拥有使其连通的最少的边数。

不难发现，上述子图可以存在若干个。那么，加上“最小”的限制以后，最小生成树就是这些子图中，边权和最小的子图。

![原图](%E5%8E%9F%E5%9B%BE.png)

![上图的最小生成树](%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png)

那么现在要问为什么了：最小生成树有什么作用呢？

最简单的，它可以解决许多图论相关的应用问题：

考虑有若干城市，我们现在要进行光纤的建设使得城市间得以互相通信，然而不同城市之间铺设光纤的价格显然是不同的，那我们自然要找到价格最低的方案，这时候就相当于在一张无向带权图上找出它的最小生成树。

按照中学答题的套路来说，我们现在讲完了“是什么”和“为什么”，该讲“怎么做”了。

不过在这之前，请允许我介绍最小生成树（Minimum Spanning Tree）的一条重要性质。

## MST性质

对于一个无向连通图 $G=(V,E)$ ，存在点集 $U\subset V$ ，边集 $E'=\{u\in U,v\in V-U|edge(u,v)\}\subset E$ ，边集 $E'$ 中边权最小的边一定在 $G$ 的一个最小生成树中。

证明也不难，直观地看， 若 $U$ 和 $V-U$ 点集内部都已经连通，那么只要 $U$ 中的节点向 $V-U$ 中的节点任连一条边即可使得全图连通。如果我们要形成最小生成树，那我们一定要选择边权最小的那条边，其他方案一定不会更优。



好了，OIer们都说MST有三种算法，你都会写么？

## 第一种：Prim 算法

由MST性质，不难想到一个朴素的算法：建立点集 $U$ 和边集 $E‘$，向点集 $U$ 中加点，同时维护 $E'$ ，直到 $U=V$。（显然，向点集 $U$ 中加入的点除了初始随机塞一个点以外，都是要取 $E'$ 中最小边 $edge_{min}(u,v)$ 的属于 $V-U$ 的端点）

但是维护 $E'$ 显然是一个非常麻烦的事情，每次向 $U$ 中加点都会导致一批边的加入和删除，时间复杂度有点高。

为了优化，我们考虑抓住问题的关键：实际上 $E'\subseteq E''=\{u\in U,v\in V|edge(u,v)\}\subseteq E$ ，我们取出 $E'$  中的最小边，等价于取出 $E''$ 中最小且 $v\notin U$ 的边。

$E''$ 无疑是很好维护的，因为不需要删除边，只需要往里面加边就行了，非常的方便，非常的……呃，还没解决求最小边的问题呢。

我们考虑用堆维护最小边，每次取堆顶，如果取出来的边的两个端点都在 $U$ 中，这个边就可以直接弹出了。很显然，因为 $U$ 中元素是不会减少的，所以这个不满足条件的边现在不满足，以后也不会。

![Prim(Heap)](Prim(Heap).png)

学过 $Dijkstra$ 的同学可能会觉得非常眼熟，因为这个优化思路本身就是与 $Dijkstra$ 堆优化同源的。

堆优化 $Prim$ 算法的时间复杂度为 $O(|V|log|E|+|E|)$

## 第二种：Kruskal 算法

相较于 $Prim$ 算法直接模拟MST性质来建树的过程， $Kruskal$ 算法则更有想象力一些：它从小到大枚举边，如果边两端的结点已经处于同一连通块中则略过，否则将它们所处的两个连通块合并成同一个连通块。显然的，当执行合并操作时，被枚举的边是最小生成树的一部分。

为什么呢？假设我们现在枚举到 $edge(u,v)$ ，$u$ 所处的连通块我们称之为 $G_u$ ，同理 $v$ 的我们称之为 $G_v$ ，将两个连通块及之间相连的边又合并成一个新图 $G'$ ，则又回到了利用MST性质上。因为枚举是有序的，这保证了 $edge(u,v)$ 一定是这两个连通块之间最小的边，它一定在MST上。

如果存在边 $edge(u,v)$ ，则 $u,v$ 显然处于同一连通块中，那么我们将他们放入同一集合中。如果二者分属不同的集合，那么这两个集合中的点显然也互相连通，所以可以直接合并这两个集合。集合的合并，我们可以使用并查集来维护。

![Kruskal](Kruskal.png)

$Kruskal$ 算法的时间复杂度为 $|E|log|E|$ 。

不难发现 $Prim$ 算法在稠密图上会表现得比 $Kruskal$ 更优秀，但对于稀疏图则不如老K。

## 第三种：Borůvka 算法

一个非常冷门的算法，算是 $Prim$ 的进阶版。

如果说 $Prim$ 一直执着于维护一个连通块，慢慢向外拓展是单线程的话， $Borůvka$ 则是多线程地同时拓展多个连通块，遍地开花地解决问题。

它的实现过程有点像前面两者的结合体：

对于现存的所有连通块，找到它向外连出的最短边，通过这条最短边将两个连通块合并。找最短边的方法就是暴力遍历所有边，维护连通块则仍然使用并查集。

由于每次合并连通块，至少使得连通块数量减少为原来的一半，所以合并操作至多有 $log|V|$ 次，总时间复杂度为  $O((|E|+|V|)log|V|)$

**值得注意的是，为了防止存在两条相同长度的边将两个连通块连接成一个环的情况，我们取最短边的时候不仅需要以权值为第一关键字，还要设置第二关键字来确保不存在“相同”的边。

![boruvka](boruvka.png)

其实这个算法大多数时候是打不过前二者的，只能在一些特殊的图上弯道超车。



专精解决最小生成树的三种算法今天就介绍到这里，其实还有许多偏门算法可以“顺带”解决MST问题（指的就是用LCT大炮打蚊子！），不过篇幅所限就不多作介绍了。